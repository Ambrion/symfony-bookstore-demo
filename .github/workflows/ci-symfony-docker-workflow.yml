# File: .github/workflows/ci-symfony-docker-workflow.yml
name: Symfony CI/CD Pipeline (using your .docker/docker-compose.yml)

on:
    push:
        branches: [ master ]
    pull_request:
        branches: [ master ]

jobs:
    test:
        runs-on: ubuntu-latest

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            # Copy the default environment file for Docker Compose
            - name: Copy .env for Docker Compose
              working-directory: .docker
              run: cp .env.dist .env # Use .env.dist from .docker directory

            # Start services defined in both docker-compose.yml and docker-compose.ci.yml
            - name: Start Docker Compose services
              working-directory: .docker
              run: |
                  # Ensure the project root .env file exists for Symfony
                  touch ../.env # Create a base .env file in project root if it doesn't exist
                  # Start services using both main compose file and CI overrides
                  docker compose -f docker-compose.yml -f docker-compose.ci.yml up -d --wait

            # Grant necessary privileges to the user_bookstore for CI tests
            # This allows the user to create/drop databases like 'db_bookstore_test'
            - name: Grant database creation privileges to user_bookstore
              working-directory: .docker
              run: |
                  # Wait a bit more for MySQL to be fully ready after startup
                  sleep 15
                  # Execute the GRANT command in the MySQL container using the service name 'mysql'
                  # Use the password directly from the .env file or set it as a variable
                  # Using 'echo' and pipe to avoid exposing the password in the command line
                  echo "GRANT ALL PRIVILEGES ON \`db_bookstore_test%\`.* TO 'user_bookstore'@'%'; FLUSH PRIVILEGES;" | \
                  docker compose exec -T mysql mysql -u root -p"12345678" # Replace with the actual password from .env

            # Optional: Verify MySQL readiness again after granting privileges
            - name: Verify MySQL readiness after granting privileges
              working-directory: .docker
              run: |
                  # A simple check to see if the user can connect and list databases
                  # This might help catch issues if the GRANT failed silently
                  # Use the password directly here as well
                  docker compose exec -T mysql mysql -u user_bookstore -p"password_bookstore" -e "SHOW DATABASES;" || \
                  (echo "User user_bookstore could not list databases after granting privileges"; docker compose logs mysql; exit 1)

            # Install dependencies inside the PHP container
            - name: Install Composer dependencies (inside php container)
              working-directory: .docker
              run: |
                  # Ensure the vendor directory is writable by the container user if needed
                  # This step runs composer install in the PHP container
                  docker compose exec -T -u root php composer install --prefer-dist --no-progress --no-interaction

            # Configure Symfony environment variables for the test environment
            # This updates the .env file in the project root where Symfony looks for it
            - name: Prepare Symfony .env for tests
              working-directory: . # Run from project root
              run: |
                  # Append test-specific variables to the project root .env file
                  echo "APP_ENV=test" >> .env
                  # Use the 'mysql' service name as defined in the main docker-compose.yml
                  # The user 'user_bookstore' should now have privileges to create 'db_bookstore_test'
                  echo "DATABASE_URL=mysql://user_bookstore:password_bookstore@mysql:3306/db_bookstore_test?serverVersion=9.3.0&charset=utf8mb4" >> .env

            # Run database setup commands inside the PHP container
            - name: Run database migrations (if needed for tests)
              working-directory: . # Run from project root where bin/console resides
              run: |
                  # Execute console commands inside the php container
                  # The --env=test flag ensures the DATABASE_URL from the project root .env file is used
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php bin/console doctrine:database:create --if-not-exists --env=test
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php bin/console doctrine:migrations:migrate --no-interaction --env=test

            # Run your test suite
            - name: Run PHPUnit tests
              working-directory: . # Run from project root where phpunit.xml.dist might be
              run: |
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php bin/phpunit --colors=never --env=test

            # Run static analysis
            - name: Run PHPStan
              working-directory: .
              run: |
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php vendor/bin/phpstan analyse src --level=max --env=test

            # Run code style check (dry-run)
            - name: Run PHP CS Fixer (dry-run)
              working-directory: .
              run: |
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php vendor/bin/php-cs-fixer fix --dry-run --diff --verbose --env=test

            # Ensure containers are stopped even if previous steps fail
            - name: Stop and remove containers
              if: always() # Run this step regardless of success/failure
              working-directory: .docker
              run: |
                  docker compose -f docker-compose.yml -f docker-compose.ci.yml down -v --remove-orphans
