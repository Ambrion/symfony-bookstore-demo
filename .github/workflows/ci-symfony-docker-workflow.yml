# File: .github/workflows/ci-symfony-docker-workflow.yml
name: Symfony CI/CD Pipeline (using your .docker/docker-compose.yml)

on:
    push:
        branches: [ master ]
    pull_request:
        branches: [ master ]

jobs:
    test:
        runs-on: ubuntu-latest

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            # Copy the default environment file for Docker Compose
            - name: Copy .env for Docker Compose
              working-directory: .docker
              run: cp .env.dist .env # Use .env.dist from .docker directory

            # Start services defined in both docker-compose.yml and docker-compose.ci.yml
            # This merges the configurations, using docker-compose.yml as base.
            - name: Start Docker Compose services
              working-directory: .docker
              run: |
                  # Ensure the project root .env file exists for Symfony
                  touch ../.env # Create a base .env file in project root if it doesn't exist
                  # Start services using both main compose file and CI overrides
                  docker compose -f docker-compose.yml -f docker-compose.ci.yml up -d --wait

            # Optional: Add a step to verify MySQL is ready if needed
            - name: Verify MySQL readiness
              working-directory: .docker
              run: |
                  # Wait for MySQL to be ready by checking the log
                  timeout 60 sh -c 'until docker compose logs mysql 2>&1 | grep -q "ready for connections"; do sleep 2; done' || \
                  (echo "MySQL did not start within 60 seconds"; docker compose logs mysql; exit 1)

            # Install dependencies inside the PHP container
            - name: Install Composer dependencies (inside php container)
              working-directory: .docker
              run: |
                  # Ensure the vendor directory is writable by the container user if needed
                  # This step runs composer install in the PHP container
                  docker compose exec -T -u root php composer install --prefer-dist --no-progress --no-interaction

            # Configure Symfony environment variables for the test environment
            # This updates the .env file in the project root where Symfony looks for it
            - name: Prepare Symfony .env for tests
              working-directory: . # Run from project root
              run: |
                  # Append test-specific variables to the project root .env file
                  echo "APP_ENV=test" >> .env
                  # Use the 'mysql' service name as defined in the main docker-compose.yml
                  echo "DATABASE_URL=mysql://user_bookstore:password_bookstore@mysql:3306/db_bookstore?serverVersion=9.3.0&charset=utf8mb4" >> .env

            # Run database setup commands inside the PHP container
            - name: Run database migrations (if needed for tests)
              working-directory: . # Run from project root where bin/console resides
              run: |
                  # Execute console commands inside the php container
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php bin/console doctrine:database:create --if-not-exists --env=test
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php bin/console doctrine:migrations:migrate --no-interaction --env=test

            # Run your test suite
            - name: Run PHPUnit tests
              working-directory: . # Run from project root where phpunit.xml.dist might be
              run: |
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php bin/phpunit --colors=never --env=test

            # Run static analysis
            - name: Run PHPStan
              working-directory: .
              run: |
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php vendor/bin/phpstan analyse src --level=max --env=test

            # Run code style check (dry-run)
            - name: Run PHP CS Fixer (dry-run)
              working-directory: .
              run: |
                  docker compose -f .docker/docker-compose.yml -f .docker/docker-compose.ci.yml exec -T php vendor/bin/php-cs-fixer fix --dry-run --diff --verbose --env=test

            # Ensure containers are stopped even if previous steps fail
            - name: Stop and remove containers
              if: always() # Run this step regardless of success/failure
              working-directory: .docker
              run: |
                  docker compose -f docker-compose.yml -f docker-compose.ci.yml down -v --remove-orphans
